<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mesh Simplifier</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: #1a1a2e; 
      color: #eee;
      overflow: hidden;
    }
    #canvas-container {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 0;
    }
    canvas { 
      display: block; 
      touch-action: none;
    }
    
    /* Toolbar */
    #toolbar {
      position: fixed;
      top: 10px;
      left: 10px;
      bottom: 60px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 100;
      max-width: 300px;
      overflow-y: auto;
      padding-right: 5px;
    }
    #toolbar::-webkit-scrollbar { width: 6px; }
    #toolbar::-webkit-scrollbar-track { background: rgba(30, 30, 50, 0.5); border-radius: 3px; }
    #toolbar::-webkit-scrollbar-thumb { background: #4a4a6a; border-radius: 3px; }
    
    .toolbar-group {
      background: rgba(30, 30, 50, 0.95);
      border-radius: 8px;
      padding: 12px;
      border: 1px solid #3a3a5a;
      flex-shrink: 0;
    }
    .toolbar-group h3 {
      font-size: 11px;
      text-transform: uppercase;
      color: #888;
      margin-bottom: 8px;
      letter-spacing: 1px;
    }
    
    .btn {
      background: #2a2a4a;
      border: 1px solid #4a4a6a;
      color: #fff;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
      display: block;
      width: 100%;
      margin-bottom: 4px;
    }
    .btn:hover { background: #3a3a6a; border-color: #6a6a9a; }
    .btn:active { background: #4a4a7a; }
    .btn.primary { background: #4a6aaa; border-color: #6a8aca; }
    .btn.primary:hover { background: #5a7aba; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn.danger { background: #aa4a4a; border-color: #ca6a6a; }
    .btn.danger:hover { background: #ba5a5a; }
    .btn.small {
      font-size: 11px;
      padding: 4px 8px;
      margin-bottom: 0;
    }
    
    .prop-row {
      margin-bottom: 10px;
    }
    .prop-row label {
      display: block;
      font-size: 12px;
      color: #888;
      margin-bottom: 4px;
    }
    .prop-row input[type="range"] {
      width: 100%;
    }
    .prop-row .value {
      font-size: 11px;
      color: #6a8aca;
      float: right;
    }
    
    .stats-row {
      font-size: 11px;
      color: #888;
      margin-bottom: 4px;
    }
    .stats-row .label { color: #666; }
    .stats-row .value { color: #6a8aca; }
    .stats-row .value.good { color: #6aca6a; }
    .stats-row .value.warning { color: #caca6a; }
    
    /* Status bar */
    #status {
      position: fixed;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(30, 30, 50, 0.9);
      border-radius: 8px;
      padding: 10px 15px;
      font-size: 12px;
      color: #888;
      z-index: 100;
    }
    #status .hint { color: #6a8aca; }
    
    /* Progress */
    .progress-bar {
      height: 4px;
      background: #2a2a4a;
      border-radius: 2px;
      margin-top: 8px;
      overflow: hidden;
    }
    .progress-bar .fill {
      height: 100%;
      background: #4a9aff;
      width: 0%;
      transition: width 0.3s;
    }
    
    /* Toggle */
    .toggle-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .toggle-row label { font-size: 12px; color: #888; }
    input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }
    
    /* Comparison view */
    .comparison-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #3a3a5a;
    }
    .comparison-stats .col {
      text-align: center;
    }
    .comparison-stats .col-label {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    .comparison-stats .col-value {
      font-size: 14px;
      color: #6a8aca;
    }

    /* Hole list */
    .hole-list {
      max-height: 140px;
      overflow-y: auto;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #3a3a5a;
    }
    .hole-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: #888;
      margin-bottom: 6px;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <div id="toolbar">
    <div class="toolbar-group">
      <h3>1. Load Mesh</h3>
      <button class="btn" onclick="document.getElementById('file-input').click()">Load .glb / .gltf file</button>
      <input type="file" id="file-input" accept=".glb,.gltf" style="display:none">
      <div id="original-stats" style="margin-top: 8px;">
        <div class="stats-row"><span class="label">Original Vertices:</span> <span class="value" id="stat-orig-verts">-</span></div>
        <div class="stats-row"><span class="label">Original Triangles:</span> <span class="value" id="stat-orig-tris">-</span></div>
        <div class="stats-row"><span class="label">File Size:</span> <span class="value" id="stat-file-size">-</span></div>
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3>2. Fill Holes</h3>
      <button class="btn" id="detect-holes-btn" onclick="detectHoles()" disabled>Detect Holes</button>
      <div class="prop-row">
        <label>Auto-Fill Max Area <span class="value" id="hole-area-value">0.50</span></label>
        <input type="range" id="hole-area-slider" min="0.01" max="10" step="0.01" value="0.50" oninput="updateHoleArea()">
      </div>
      <button class="btn primary" id="auto-fill-btn" onclick="autoFillHoles()" disabled>Auto Fill Small Holes</button>
      <div class="stats-row"><span class="label">Holes Detected:</span> <span class="value" id="hole-count">-</span></div>
      <div class="hole-list" id="hole-list"></div>
    </div>
    
    <div class="toolbar-group">
      <h3>3. Patch Tool</h3>
      <div class="toggle-row">
        <input type="checkbox" id="patch-mode" onchange="togglePatchMode()">
        <label for="patch-mode">Enable Patch Mode</label>
      </div>
      <div class="toggle-row">
        <input type="checkbox" id="snap-to-surface" checked onchange="toggleSnapToSurface()">
        <label for="snap-to-surface">Snap to mesh surface</label>
      </div>
      <div class="toggle-row">
        <input type="checkbox" id="align-to-normal" onchange="toggleAlignToNormal()">
        <label for="align-to-normal">Align to surface normal</label>
      </div>
      <div class="prop-row">
        <label>Patch Size <span class="value" id="patch-size-value">0.50</span></label>
        <input type="range" id="patch-size" min="0.05" max="5" step="0.05" value="0.50" oninput="updatePatchSize()">
      </div>
      <div class="prop-row">
        <label>Patch Distance (fallback) <span class="value" id="patch-distance-value">1.00</span></label>
        <input type="range" id="patch-distance" min="0.1" max="10" step="0.1" value="1.00" oninput="updatePatchDistance()">
      </div>
      <div class="prop-row">
        <label>Brush Spacing <span class="value" id="patch-spacing-value">0.25</span></label>
        <input type="range" id="patch-spacing" min="0.05" max="2" step="0.05" value="0.25" oninput="updatePatchSpacing()">
      </div>
      <div class="stats-row">
        Click/drag to paint quads onto the mesh. Patches face the camera.
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3>4. Simplify</h3>
      <div class="prop-row">
        <label>Target Reduction <span class="value" id="reduction-value">50%</span></label>
        <input type="range" id="reduction-slider" min="10" max="95" value="50" oninput="updateReductionValue()">
      </div>
      <div class="prop-row">
        <label>Target Triangles <span class="value" id="target-tris-value">-</span></label>
      </div>
      <button class="btn primary" id="simplify-btn" onclick="simplifyMesh()" disabled>Simplify Mesh</button>
      <div class="progress-bar"><div class="fill" id="progress"></div></div>
      
      <div class="comparison-stats" id="comparison-stats" style="display: none;">
        <div class="col">
          <div class="col-label">Original</div>
          <div class="col-value" id="compare-orig">-</div>
        </div>
        <div class="col">
          <div class="col-label">Simplified</div>
          <div class="col-value" id="compare-simplified">-</div>
        </div>
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3>5. Preview</h3>
      <div class="toggle-row">
        <input type="checkbox" id="show-original" checked onchange="toggleOriginal()">
        <label for="show-original">Show original (gray)</label>
      </div>
      <div class="toggle-row">
        <input type="checkbox" id="show-simplified" checked onchange="toggleSimplified()">
        <label for="show-simplified">Show simplified (blue)</label>
      </div>
      <div class="toggle-row">
        <input type="checkbox" id="show-wireframe" onchange="toggleWireframe()">
        <label for="show-wireframe">Wireframe mode</label>
      </div>
      <div class="prop-row">
        <label>Move Speed <span class="value" id="speed-value">0.15</span></label>
        <input type="range" id="speed-slider" min="0.01" max="1" step="0.01" value="0.15" oninput="updateSpeed()">
      </div>
      <button class="btn" onclick="resetCamera()">Reset Camera</button>
    </div>
    
    <div class="toolbar-group">
      <h3>6. Export</h3>
      <button class="btn primary" id="export-btn" onclick="exportGLB()" disabled>Export Simplified .glb</button>
      <div class="stats-row" style="margin-top: 8px;">
        <span class="label">Reduction:</span> <span class="value" id="stat-reduction">-</span>
      </div>
    </div>
  </div>
  
  <div id="status">
    Loading meshoptimizer...
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
  }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    
    // Load three-mesh-bvh for fast raycasting
    let bvhReady = false;
    let computeBoundsTree, disposeBoundsTree, acceleratedRaycast;
    
    async function initBVH() {
      try {
        const bvhModule = await import('https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.7.8/+esm');
        computeBoundsTree = bvhModule.computeBoundsTree;
        disposeBoundsTree = bvhModule.disposeBoundsTree;
        acceleratedRaycast = bvhModule.acceleratedRaycast;
        
        // Extend Three.js with BVH acceleration
        THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
        THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
        THREE.Mesh.prototype.raycast = acceleratedRaycast;
        
        bvhReady = true;
        console.log('three-mesh-bvh loaded and ready');
      } catch (err) {
        console.warn('Failed to load three-mesh-bvh, raycasting will be slow:', err);
      }
    }
    initBVH();
    // No orbit/pointer lock controls; we use drag-to-look + WASD.
    
    // ========== Utilities (defined early for initMeshopt) ==========
    function setStatus(msg) {
      document.getElementById('status').innerHTML = msg;
    }
    
    function setProgress(percent) {
      document.getElementById('progress').style.width = percent + '%';
    }
    
    // ========== Meshoptimizer WASM (fast O(n log n) simplification) ==========
    // meshoptimizer by Arseny Kapoulkine - used by Unity, Unreal, etc.
    // Much faster than Three.js SimplifyModifier for large meshes
    let meshoptReady = false;
    let MeshoptSimplifier = null;
    
    // Load meshoptimizer WASM
    async function initMeshopt() {
      try {
        setStatus('Loading meshoptimizer WASM...');
        const module = await import('https://cdn.jsdelivr.net/npm/meshoptimizer@0.21.0/meshopt_simplifier.module.js');
        console.log('Meshopt module:', module);
        console.log('Module keys:', Object.keys(module));
        
        MeshoptSimplifier = module.MeshoptSimplifier;
        console.log('MeshoptSimplifier:', MeshoptSimplifier);
        console.log('MeshoptSimplifier methods:', Object.keys(MeshoptSimplifier));
        
        await MeshoptSimplifier.ready;
        meshoptReady = true;
        
        // Quick test with tiny mesh
        const testIndices = new Uint32Array([0, 1, 2]);
        const testVerts = new Float32Array([0,0,0, 1,0,0, 0,1,0]);
        const testResult = MeshoptSimplifier.simplify(testIndices, testVerts, 3, 3, 0.01);
        console.log('Test simplify result:', testResult, 'length:', testResult[0]?.length);
        
        setStatus('<span class="hint">Drag</span> to look. WASD to move, mouse drag to look, R/F (or Q/E) up/down, Shift = fast.');
        console.log('Meshoptimizer ready');
      } catch (err) {
        console.error('Failed to load meshoptimizer:', err);
        setStatus('Error: Failed to load meshoptimizer. Check console.');
      }
    }
    initMeshopt();
    
    // ========== Scene Setup ==========
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 10000);
    camera.position.set(5, 5, 5);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);
    
    camera.rotation.order = 'YXZ';
    
    // ========== State ==========
    let originalMesh = null;
    let simplifiedMesh = null;
    let originalTriCount = 0;
    let originalVertCount = 0;
    let fileSize = 0;
    let holeLoops = [];
    let holeAreaThreshold = 0.5;
    let patchMode = false;
    let patchSize = 0.5;
    let patchDistance = 1.0;
    let patchSpacing = 0.25;
    let patchPlane = null;
    let isPainting = false;
    let lastPaintPosition = null;
    let snapToSurface = true;  // Snap patches to mesh surface
    let alignToNormal = false; // Align patch to surface normal (vs face camera)
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    // ========== WASD + Drag-Look Controls ==========
    const keyState = {};
    let moveSpeed = 0.15;
    let isMouseDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let yaw = 0;
    let pitch = 0;
    const lookSensitivity = 0.0025;
    
    document.addEventListener('keydown', (e) => {
      keyState[e.code] = true;
      // Prevent default for movement keys
      if (['KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyQ', 'KeyE', 'KeyR', 'KeyF', 'Space', 'ShiftLeft', 'ShiftRight'].includes(e.code)) {
        e.preventDefault();
      }
    });
    
    document.addEventListener('keyup', (e) => {
      keyState[e.code] = false;
    });

    renderer.domElement.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      isMouseDragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });

    renderer.domElement.addEventListener('mouseup', () => {
      isMouseDragging = false;
    });

    renderer.domElement.addEventListener('mouseleave', () => {
      isMouseDragging = false;
    });

    renderer.domElement.addEventListener('mousemove', (e) => {
      if (!isMouseDragging) return;
      const dx = e.clientX - lastMouseX;
      const dy = e.clientY - lastMouseY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;

      yaw -= dx * lookSensitivity;
      pitch -= dy * lookSensitivity;
      const maxPitch = Math.PI / 2 - 0.01;
      pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));

      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
    });
    
    function updateMovement() {
      // Speed modifier
      const speed = keyState['ShiftLeft'] || keyState['ShiftRight'] ? moveSpeed * 3 : moveSpeed;
      
      // Get camera direction vectors
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();

      const right = new THREE.Vector3();
      right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

      const movement = new THREE.Vector3();

      // WASD movement
      if (keyState['KeyW'] || keyState['ArrowUp']) movement.add(forward.clone().multiplyScalar(speed));
      if (keyState['KeyS'] || keyState['ArrowDown']) movement.add(forward.clone().multiplyScalar(-speed));
      if (keyState['KeyA'] || keyState['ArrowLeft']) movement.add(right.clone().multiplyScalar(-speed));
      if (keyState['KeyD'] || keyState['ArrowRight']) movement.add(right.clone().multiplyScalar(speed));

      // Q/E/R/F or Space for up/down
      if (keyState['KeyE'] || keyState['KeyR'] || keyState['Space']) movement.y += speed;
      if (keyState['KeyQ'] || keyState['KeyF']) movement.y -= speed;

      if (movement.lengthSq() > 0) {
        camera.position.add(movement);
      }
    }

    // Patch mode mouse handling (throttled to avoid constant raycasting)
    let patchUpdatePending = false;
    renderer.domElement.addEventListener('mousemove', (e) => {
      if (!patchMode) return;
      updateMouse(e);
      
      // Throttle raycast updates
      if (!patchUpdatePending) {
        patchUpdatePending = true;
        requestAnimationFrame(() => {
          updatePatchPlane();
          if (isPainting) {
            maybePaintPatch();
          }
          patchUpdatePending = false;
        });
      }
    });

    renderer.domElement.addEventListener('mousedown', (e) => {
      if (!patchMode || e.button !== 0) return;
      updateMouse(e);
      updatePatchPlane();
      isPainting = true;
      lastPaintPosition = null;
      placePatch();
    });

    renderer.domElement.addEventListener('mouseup', () => {
      isPainting = false;
      lastPaintPosition = null;
    });

    function updateMouse(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function updatePatchPlane() {
      raycaster.setFromCamera(mouse, camera);
      
      // If snap-to-surface is enabled, try to hit the mesh
      if (snapToSurface && originalMesh) {
        // Temporarily make mesh visible for raycasting (raycast ignores invisible objects)
        const wasVisible = originalMesh.visible;
        originalMesh.visible = true;
        
        const intersects = raycaster.intersectObject(originalMesh, false);
        
        // Restore visibility
        originalMesh.visible = wasVisible || document.getElementById('show-original').checked;
        
        if (intersects.length > 0) {
          const hit = intersects[0];
          patchPlane.position.copy(hit.point);
          
          // Offset slightly towards camera so patch sits ON surface, not inside
          const toCamera = camera.position.clone().sub(hit.point).normalize();
          patchPlane.position.addScaledVector(toCamera, 0.01);
          
          // Optionally align to surface normal or face camera
          if (alignToNormal && hit.face) {
            // Align patch to surface normal
            const normal = hit.face.normal.clone().transformDirection(originalMesh.matrixWorld);
            patchPlane.lookAt(patchPlane.position.clone().add(normal));
          } else {
            patchPlane.lookAt(camera.position);
          }
          patchPlane.scale.setScalar(patchSize);
          patchPlane.material.color.setHex(0x44ff44); // Green = on surface
          return;
        }
      }
      
      // Fallback: place at fixed distance (red = not on surface)
      const point = raycaster.ray.at(patchDistance, new THREE.Vector3());
      patchPlane.position.copy(point);
      patchPlane.scale.setScalar(patchSize);
      patchPlane.lookAt(camera.position);
      patchPlane.material.color.setHex(0xff4444); // Red = floating
    }

    function maybePaintPatch() {
      if (!patchPlane.visible) return;
      const current = patchPlane.position.clone();
      if (!lastPaintPosition || current.distanceTo(lastPaintPosition) >= patchSpacing) {
        placePatch();
        lastPaintPosition = current.clone();
      }
    }
    
    // Grid helper
    const grid = new THREE.GridHelper(20, 20, 0x444444, 0x333333);
    scene.add(grid);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);

    // Patch preview plane (hidden until patch mode)
    const patchGeometry = new THREE.PlaneGeometry(1, 1);
    const patchMaterial = new THREE.MeshBasicMaterial({
      color: 0x44ff44,
      transparent: true,
      opacity: 0.35,
      side: THREE.DoubleSide,
      depthTest: true,
      depthWrite: false
    });
    patchPlane = new THREE.Mesh(patchGeometry, patchMaterial);
    patchPlane.visible = false;
    scene.add(patchPlane);
    
    // ========== File Loading ==========
    const fileInput = document.getElementById('file-input');
    
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
    
    document.addEventListener('drop', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      const file = e.dataTransfer.files[0];
      if (file && (file.name.endsWith('.glb') || file.name.endsWith('.gltf'))) {
        await loadGLBFile(file);
      }
    });
    
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) {
        await loadGLBFile(file);
      }
    });
    
    async function loadGLBFile(file) {
      try {
        setStatus('Loading mesh...');
        fileSize = file.size;
        
        const arrayBuffer = await file.arrayBuffer();
        const loader = new GLTFLoader();
        
        const gltf = await new Promise((resolve, reject) => {
          loader.parse(arrayBuffer, '', resolve, reject);
        });
        
        // Remove existing meshes
        if (originalMesh) {
          scene.remove(originalMesh);
          originalMesh.geometry.dispose();
          originalMesh.material.dispose();
        }
        if (simplifiedMesh) {
          scene.remove(simplifiedMesh);
          simplifiedMesh.geometry.dispose();
          simplifiedMesh.material.dispose();
          simplifiedMesh = null;
        }
        
        // Find all meshes and merge them
        const geometries = [];
        gltf.scene.traverse((child) => {
          if (child.isMesh) {
            const geo = child.geometry.clone();
            child.updateWorldMatrix(true, false);
            geo.applyMatrix4(child.matrixWorld);
            geometries.push(geo);
          }
        });
        
        if (geometries.length === 0) {
          setStatus('Error: No mesh found in file');
          return;
        }
        
        // Merge geometries if multiple
        let mergedGeometry;
        if (geometries.length === 1) {
          mergedGeometry = geometries[0];
        } else {
          mergedGeometry = mergeBufferGeometries(geometries);
        }
        
        // Make sure it's indexed (required for SimplifyModifier)
        if (!mergedGeometry.index) {
          mergedGeometry = toIndexedGeometry(mergedGeometry);
        }
        
        // Create original mesh (gray, slightly transparent)
        const originalMaterial = new THREE.MeshStandardMaterial({
          color: 0x888888,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.5
        });
        
        originalMesh = new THREE.Mesh(mergedGeometry, originalMaterial);
        originalMesh.visible = document.getElementById('show-original').checked;
        scene.add(originalMesh);
        
        // Build BVH for fast raycasting (critical for large meshes)
        if (bvhReady && mergedGeometry.computeBoundsTree) {
          setStatus('Building BVH for fast raycasting...');
          await new Promise(resolve => setTimeout(resolve, 10));
          mergedGeometry.computeBoundsTree();
          console.log('BVH built for', originalTriCount, 'triangles');
        } else {
          console.warn('BVH not available, raycasting may be slow');
        }

        // Reset hole detection UI
        holeLoops = [];
        document.getElementById('hole-count').textContent = '-';
        document.getElementById('hole-list').innerHTML = '';
        document.getElementById('detect-holes-btn').disabled = false;
        document.getElementById('auto-fill-btn').disabled = true;
        
        // Update stats
        originalVertCount = mergedGeometry.getAttribute('position').count;
        originalTriCount = mergedGeometry.index ? mergedGeometry.index.count / 3 : originalVertCount / 3;
        
        document.getElementById('stat-orig-verts').textContent = originalVertCount.toLocaleString();
        document.getElementById('stat-orig-tris').textContent = Math.floor(originalTriCount).toLocaleString();
        document.getElementById('stat-file-size').textContent = formatFileSize(fileSize);
        
        // Enable simplify button
        document.getElementById('simplify-btn').disabled = false;
        updateReductionValue();
        
        // Center camera
        centerCamera();
        
        // Hide comparison stats
        document.getElementById('comparison-stats').style.display = 'none';
        document.getElementById('export-btn').disabled = true;
        document.getElementById('stat-reduction').textContent = '-';
        
        setStatus(`Loaded mesh with ${originalTriCount.toLocaleString()} triangles. Adjust reduction and click Simplify.`);
        
      } catch (err) {
        console.error('Error loading GLB:', err);
        setStatus('Error: ' + err.message);
      }
    }
    
    // Simple geometry merge (since BufferGeometryUtils may not be in all Three.js versions)
    function mergeBufferGeometries(geometries) {
      const positions = [];
      const indices = [];
      let indexOffset = 0;
      
      for (const geo of geometries) {
        const pos = geo.getAttribute('position');
        for (let i = 0; i < pos.count; i++) {
          positions.push(pos.getX(i), pos.getY(i), pos.getZ(i));
        }
        
        if (geo.index) {
          const idx = geo.index;
          for (let i = 0; i < idx.count; i++) {
            indices.push(idx.getX(i) + indexOffset);
          }
        } else {
          for (let i = 0; i < pos.count; i++) {
            indices.push(i + indexOffset);
          }
        }
        
        indexOffset += pos.count;
      }
      
      const merged = new THREE.BufferGeometry();
      merged.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      merged.setIndex(indices);
      merged.computeVertexNormals();
      
      return merged;
    }
    
    // Convert non-indexed geometry to indexed
    function toIndexedGeometry(geometry) {
      const positions = geometry.getAttribute('position');
      const vertexMap = new Map();
      const newPositions = [];
      const indices = [];
      
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;
        
        if (vertexMap.has(key)) {
          indices.push(vertexMap.get(key));
        } else {
          const idx = newPositions.length / 3;
          vertexMap.set(key, idx);
          newPositions.push(x, y, z);
          indices.push(idx);
        }
      }
      
      const indexed = new THREE.BufferGeometry();
      indexed.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
      indexed.setIndex(indices);
      indexed.computeVertexNormals();
      
      return indexed;
    }
    
    function centerCamera() {
      if (!originalMesh) return;
      
      const bounds = new THREE.Box3().setFromObject(originalMesh);
      const center = bounds.getCenter(new THREE.Vector3());
      const size = bounds.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z) || 10;
      
      camera.position.set(
        center.x + maxDim * 1.2,
        center.y + maxDim * 0.8,
        center.z + maxDim * 1.2
      );
      camera.lookAt(center);
      yaw = camera.rotation.y;
      pitch = camera.rotation.x;
    }
    
    window.resetCamera = centerCamera;
    
    window.updateSpeed = function() {
      moveSpeed = parseFloat(document.getElementById('speed-slider').value);
      document.getElementById('speed-value').textContent = moveSpeed.toFixed(2);
    };

    // Initialize patch UI values (after functions are defined)
    setTimeout(() => {
      window.updatePatchSize();
      window.updatePatchDistance();
      window.updatePatchSpacing();
    }, 0);

    // ========== Hole Detection & Filling ==========
    window.updateHoleArea = function() {
      holeAreaThreshold = parseFloat(document.getElementById('hole-area-slider').value);
      document.getElementById('hole-area-value').textContent = holeAreaThreshold.toFixed(2);
    };

    window.togglePatchMode = function() {
      patchMode = document.getElementById('patch-mode').checked;
      patchPlane.visible = patchMode;
      isPainting = false;
      lastPaintPosition = null;
      if (patchMode) {
        setStatus('Patch mode enabled. Click/drag to paint quads (faces camera).');
      } else {
        setStatus('Patch mode disabled.');
      }
    };

    window.updatePatchSize = function() {
      patchSize = parseFloat(document.getElementById('patch-size').value);
      document.getElementById('patch-size-value').textContent = patchSize.toFixed(2);
      if (patchPlane) patchPlane.scale.setScalar(patchSize);
    };

    window.updatePatchDistance = function() {
      patchDistance = parseFloat(document.getElementById('patch-distance').value);
      document.getElementById('patch-distance-value').textContent = patchDistance.toFixed(2);
    };

    window.toggleSnapToSurface = function() {
      snapToSurface = document.getElementById('snap-to-surface').checked;
    };

    window.toggleAlignToNormal = function() {
      alignToNormal = document.getElementById('align-to-normal').checked;
    };

    window.updatePatchSpacing = function() {
      patchSpacing = parseFloat(document.getElementById('patch-spacing').value);
      document.getElementById('patch-spacing-value').textContent = patchSpacing.toFixed(2);
    };

    window.detectHoles = function() {
      if (!originalMesh) return;
      holeLoops = findHoles(originalMesh.geometry);
      renderHoleList();
      setStatus(`Detected ${holeLoops.length} hole(s). You can auto-fill small holes or fill manually.`);
    };

    window.autoFillHoles = function() {
      if (!originalMesh || holeLoops.length === 0) return;
      const threshold = holeAreaThreshold;
      let filled = 0;

      // Fill smallest holes first
      const sorted = [...holeLoops].sort((a, b) => a.area - b.area);
      for (const hole of sorted) {
        if (hole.area <= threshold) {
          if (fillHoleLoop(hole)) {
            filled++;
          }
        }
      }

      if (filled > 0) {
        holeLoops = findHoles(originalMesh.geometry);
        renderHoleList();
        updateOriginalStats();
        setStatus(`Auto-filled ${filled} hole(s). Remaining: ${holeLoops.length}.`);
      } else {
        setStatus('No holes matched the auto-fill threshold.');
      }
    };

    window.fillHole = function(index) {
      if (!originalMesh || !holeLoops[index]) return;
      const hole = holeLoops[index];
      if (fillHoleLoop(hole)) {
        holeLoops = findHoles(originalMesh.geometry);
        renderHoleList();
        updateOriginalStats();
        setStatus(`Filled hole ${index + 1}. Remaining: ${holeLoops.length}.`);
      }
    };

    function findHoles(geometry) {
      const index = geometry.getIndex();
      if (!index) return [];

      const edgeCount = new Map();
      const edgeKey = (a, b) => (a < b ? `${a}_${b}` : `${b}_${a}`);
      const addEdge = (a, b) => {
        const key = edgeKey(a, b);
        edgeCount.set(key, (edgeCount.get(key) || 0) + 1);
      };

      for (let i = 0; i < index.count; i += 3) {
        const a = index.getX(i);
        const b = index.getX(i + 1);
        const c = index.getX(i + 2);
        addEdge(a, b);
        addEdge(b, c);
        addEdge(c, a);
      }

      // Build boundary adjacency
      const adjacency = new Map();
      edgeCount.forEach((count, key) => {
        if (count === 1) {
          const [a, b] = key.split('_').map(Number);
          if (!adjacency.has(a)) adjacency.set(a, []);
          if (!adjacency.has(b)) adjacency.set(b, []);
          adjacency.get(a).push(b);
          adjacency.get(b).push(a);
        }
      });

      const loops = [];
      const visited = new Set();
      const markVisited = (a, b) => visited.add(edgeKey(a, b));
      const isVisited = (a, b) => visited.has(edgeKey(a, b));

      adjacency.forEach((neighbors, start) => {
        for (const next of neighbors) {
          if (isVisited(start, next)) continue;

          const loop = [start, next];
          markVisited(start, next);
          let prev = start;
          let current = next;
          let safety = 0;

          while (safety++ < 10000) {
            const nbrs = adjacency.get(current) || [];
            let candidate = null;

            for (const n of nbrs) {
              if (n === prev) continue;
              if (!isVisited(current, n)) {
                candidate = n;
                break;
              }
            }

            if (candidate === null && nbrs.includes(start)) {
              candidate = start;
            }

            if (candidate === null) break;
            if (candidate === start) {
              markVisited(current, candidate);
              break;
            }

            loop.push(candidate);
            markVisited(current, candidate);
            prev = current;
            current = candidate;
          }

          if (loop.length >= 3) {
            loops.push(computeLoopMetrics(loop, geometry.getAttribute('position')));
          }
        }
      });

      return loops;
    }

    function computeLoopMetrics(loop, positions) {
      const points = loop.map((i) => new THREE.Vector3(
        positions.getX(i),
        positions.getY(i),
        positions.getZ(i)
      ));

      // Newell's method for normal and area
      const normal = new THREE.Vector3();
      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        const q = points[(i + 1) % points.length];
        normal.x += (p.y - q.y) * (p.z + q.z);
        normal.y += (p.z - q.z) * (p.x + q.x);
        normal.z += (p.x - q.x) * (p.y + q.y);
      }

      const area = 0.5 * normal.length();
      const n = normal.lengthSq() > 0 ? normal.normalize() : new THREE.Vector3(0, 1, 0);

      let perimeter = 0;
      for (let i = 0; i < points.length; i++) {
        perimeter += points[i].distanceTo(points[(i + 1) % points.length]);
      }

      const centroid = new THREE.Vector3();
      points.forEach((p) => centroid.add(p));
      centroid.multiplyScalar(1 / points.length);

      return {
        vertices: loop,
        area,
        perimeter,
        normal: n,
        centroid,
        pointCount: points.length
      };
    }

    function triangulateLoop(loopData, geometry) {
      const positions = geometry.getAttribute('position');
      const points3D = loopData.vertices.map((i) => new THREE.Vector3(
        positions.getX(i),
        positions.getY(i),
        positions.getZ(i)
      ));

      const n = loopData.normal.clone().normalize();
      let u = new THREE.Vector3(1, 0, 0);
      if (Math.abs(n.dot(u)) > 0.9) u.set(0, 1, 0);
      u = new THREE.Vector3().crossVectors(n, u).normalize();
      const v = new THREE.Vector3().crossVectors(n, u).normalize();

      const points2D = points3D.map((p) => ({
        x: p.dot(u),
        y: p.dot(v)
      }));

      const triIndices = earClipPolygon(points2D);
      if (!triIndices) return null;

      const result = [];
      for (const tri of triIndices) {
        result.push(
          loopData.vertices[tri[0]],
          loopData.vertices[tri[1]],
          loopData.vertices[tri[2]]
        );
      }
      return result;
    }

    function earClipPolygon(points) {
      const n = points.length;
      if (n < 3) return null;

      const area = polygonArea2D(points);
      if (Math.abs(area) < 1e-8) return null;
      const isCCW = area > 0;

      const indices = Array.from({ length: n }, (_, i) => i);
      const triangles = [];

      let safety = 0;
      while (indices.length > 3 && safety++ < 10000) {
        let earFound = false;

        for (let i = 0; i < indices.length; i++) {
          const i0 = indices[(i - 1 + indices.length) % indices.length];
          const i1 = indices[i];
          const i2 = indices[(i + 1) % indices.length];

          if (!isConvex(points[i0], points[i1], points[i2], isCCW)) continue;

          let containsPoint = false;
          for (let j = 0; j < indices.length; j++) {
            const ij = indices[j];
            if (ij === i0 || ij === i1 || ij === i2) continue;
            if (pointInTriangle(points[ij], points[i0], points[i1], points[i2])) {
              containsPoint = true;
              break;
            }
          }
          if (containsPoint) continue;

          if (isCCW) {
            triangles.push([i0, i1, i2]);
          } else {
            triangles.push([i0, i2, i1]);
          }

          indices.splice(i, 1);
          earFound = true;
          break;
        }

        if (!earFound) return null;
      }

      if (indices.length === 3) {
        if (isCCW) {
          triangles.push([indices[0], indices[1], indices[2]]);
        } else {
          triangles.push([indices[0], indices[2], indices[1]]);
        }
      }

      return triangles;
    }

    function polygonArea2D(points) {
      let area = 0;
      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        const q = points[(i + 1) % points.length];
        area += p.x * q.y - q.x * p.y;
      }
      return area * 0.5;
    }

    function isConvex(a, b, c, isCCW) {
      const cross = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
      return isCCW ? cross > 1e-8 : cross < -1e-8;
    }

    function pointInTriangle(p, a, b, c) {
      const v0x = c.x - a.x;
      const v0y = c.y - a.y;
      const v1x = b.x - a.x;
      const v1y = b.y - a.y;
      const v2x = p.x - a.x;
      const v2y = p.y - a.y;

      const dot00 = v0x * v0x + v0y * v0y;
      const dot01 = v0x * v1x + v0y * v1y;
      const dot02 = v0x * v2x + v0y * v2y;
      const dot11 = v1x * v1x + v1y * v1y;
      const dot12 = v1x * v2x + v1y * v2y;

      const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
      const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

      return u >= 0 && v >= 0 && (u + v) <= 1;
    }

    function fillHoleLoop(loopData) {
      const geometry = originalMesh.geometry;
      const triangles = triangulateLoop(loopData, geometry);
      if (!triangles || triangles.length === 0) {
        setStatus('Failed to triangulate hole. Try manual fill or adjust geometry.');
        return false;
      }

      const index = geometry.getIndex();
      const oldArray = index.array;
      const newArray = new oldArray.constructor(oldArray.length + triangles.length);
      newArray.set(oldArray);
      newArray.set(triangles, oldArray.length);
      geometry.setIndex(newArray);
      geometry.computeVertexNormals();
      geometry.computeBoundingSphere();

      return true;
    }

    function renderHoleList() {
      const list = document.getElementById('hole-list');
      list.innerHTML = '';
      document.getElementById('hole-count').textContent = holeLoops.length.toString();
      document.getElementById('auto-fill-btn').disabled = holeLoops.length === 0;

      if (holeLoops.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'stats-row';
        empty.textContent = 'No boundary holes detected.';
        list.appendChild(empty);
        return;
      }

      holeLoops.forEach((hole, idx) => {
        const item = document.createElement('div');
        item.className = 'hole-item';

        const label = document.createElement('div');
        label.textContent = `Hole ${idx + 1} • area ${hole.area.toFixed(2)} • edges ${hole.pointCount}`;

        const btn = document.createElement('button');
        btn.className = 'btn small';
        btn.textContent = 'Fill';
        btn.onclick = () => window.fillHole(idx);

        item.appendChild(label);
        item.appendChild(btn);
        list.appendChild(item);
      });
    }

    function updateOriginalStats() {
      if (!originalMesh) return;
      const geometry = originalMesh.geometry;
      originalVertCount = geometry.getAttribute('position').count;
      originalTriCount = geometry.getIndex() ? geometry.getIndex().count / 3 : originalVertCount / 3;
      document.getElementById('stat-orig-verts').textContent = originalVertCount.toLocaleString();
      document.getElementById('stat-orig-tris').textContent = Math.floor(originalTriCount).toLocaleString();
      window.updateReductionValue();
    }

    function placePatch() {
      if (!originalMesh || !patchPlane.visible) return;

      try {
        const oldGeometry = originalMesh.geometry;
        const posAttr = oldGeometry.getAttribute('position');
        if (!posAttr) return;

        // Compute quad corners in world space
        const half = patchSize * 0.5;
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(patchPlane.quaternion);
        const up = new THREE.Vector3(0, 1, 0).applyQuaternion(patchPlane.quaternion);
        const center = patchPlane.position.clone();

        const p0 = center.clone().addScaledVector(right, -half).addScaledVector(up, -half);
        const p1 = center.clone().addScaledVector(right, half).addScaledVector(up, -half);
        const p2 = center.clone().addScaledVector(right, -half).addScaledVector(up, half);
        const p3 = center.clone().addScaledVector(right, half).addScaledVector(up, half);

        const oldVertexCount = posAttr.count;
        const baseIndex = oldVertexCount;
        const newVertexCount = oldVertexCount + 4;

        // Copy positions safely (handles interleaved attributes)
        const newPositions = new Float32Array(newVertexCount * 3);
        for (let i = 0; i < oldVertexCount; i++) {
          newPositions[i * 3] = posAttr.getX(i);
          newPositions[i * 3 + 1] = posAttr.getY(i);
          newPositions[i * 3 + 2] = posAttr.getZ(i);
        }
        newPositions.set(
          [p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z],
          oldVertexCount * 3
        );

        // Build index buffer
        const oldIndexAttr = oldGeometry.getIndex();
        const oldIndexCount = oldIndexAttr ? oldIndexAttr.count : oldVertexCount;
        const newIndices = new Uint32Array(oldIndexCount + 6);

        if (oldIndexAttr) {
          for (let i = 0; i < oldIndexCount; i++) {
            newIndices[i] = oldIndexAttr.getX(i);
          }
        } else {
          for (let i = 0; i < oldVertexCount; i++) {
            newIndices[i] = i;
          }
        }

        // Two triangles: (p0, p1, p2) and (p2, p1, p3)
        newIndices[oldIndexCount] = baseIndex;
        newIndices[oldIndexCount + 1] = baseIndex + 1;
        newIndices[oldIndexCount + 2] = baseIndex + 2;
        newIndices[oldIndexCount + 3] = baseIndex + 2;
        newIndices[oldIndexCount + 4] = baseIndex + 1;
        newIndices[oldIndexCount + 5] = baseIndex + 3;

        // Create entirely new geometry to avoid WebGL buffer issues
        const newGeometry = new THREE.BufferGeometry();
        newGeometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
        newGeometry.setIndex(new THREE.BufferAttribute(newIndices, 1));
        newGeometry.computeVertexNormals();
        newGeometry.computeBoundingSphere();

        // Swap geometry
        originalMesh.geometry = newGeometry;
        if (oldGeometry.disposeBoundsTree) oldGeometry.disposeBoundsTree();
        oldGeometry.dispose();
        
        // Rebuild BVH for continued raycasting
        if (bvhReady && newGeometry.computeBoundsTree) {
          newGeometry.computeBoundsTree();
        }

        updateOriginalStats();
      } catch (err) {
        console.error('placePatch error:', err);
        setStatus('Error placing patch: ' + err.message);
      }
    }
    
    // ========== Simplification ==========
    window.updateReductionValue = function() {
      const val = document.getElementById('reduction-slider').value;
      document.getElementById('reduction-value').textContent = val + '%';
      
      if (originalTriCount > 0) {
        const targetTris = Math.floor(originalTriCount * (1 - val / 100));
        document.getElementById('target-tris-value').textContent = targetTris.toLocaleString();
      }
    };
    
    window.simplifyMesh = async function() {
      if (!originalMesh) return;
      
      if (!meshoptReady) {
        setStatus('Error: meshoptimizer not loaded yet. Please wait...');
        return;
      }
      
      setStatus('Simplifying mesh (meshoptimizer)...');
      setProgress(10);
      
      // Allow UI to update
      await new Promise(resolve => setTimeout(resolve, 50));
      
      const startTime = performance.now();
      
      try {
        const reduction = document.getElementById('reduction-slider').value / 100;
        const targetTriCount = Math.max(4, Math.floor(originalTriCount * (1 - reduction)));
        
        // Get geometry data
        const geometry = originalMesh.geometry;
        const positions = geometry.getAttribute('position');
        const index = geometry.getIndex();
        
        if (!index) {
          setStatus('Error: Mesh must be indexed');
          return;
        }
        
        // Convert to flat arrays for meshoptimizer
        const vertexCount = positions.count;
        const indexCount = index.count;
        
        // Create vertex array (positions only, 3 floats per vertex)
        const vertices = new Float32Array(vertexCount * 3);
        for (let i = 0; i < vertexCount; i++) {
          vertices[i * 3] = positions.getX(i);
          vertices[i * 3 + 1] = positions.getY(i);
          vertices[i * 3 + 2] = positions.getZ(i);
        }
        
        // Create index array
        const indices = new Uint32Array(indexCount);
        for (let i = 0; i < indexCount; i++) {
          indices[i] = index.getX(i);
        }
        
        // Debug: Check data validity (sample only to avoid perf issues)
        let maxIdx = 0;
        for (let i = 0; i < indices.length; i++) {
          if (indices[i] > maxIdx) maxIdx = indices[i];
        }
        
        console.log('Input validation:', {
          vertexCount,
          indexCount,
          triangleCount: indexCount / 3,
          verticesArrayLength: vertices.length,
          indicesArrayLength: indices.length,
          maxIndex: maxIdx,
          sampleVertices: [vertices[0], vertices[1], vertices[2]],
          sampleIndices: [indices[0], indices[1], indices[2]]
        });
        
        // Validate indices are within bounds
        if (maxIdx >= vertexCount) {
          console.error('Invalid mesh: index', maxIdx, 'exceeds vertex count', vertexCount);
          setStatus('Error: Invalid mesh - indices out of bounds');
          return;
        }
        
        setProgress(30);
        setStatus(`Simplifying ${originalTriCount.toLocaleString()} → ${targetTriCount.toLocaleString()} triangles...`);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        console.log(`Simplifying: ${indexCount / 3} -> ${targetTriCount} triangles`);
        
        // Run meshoptimizer simplification
        // simplify(indices, vertices, vertex_stride, target_index_count, target_error)
        // Returns [simplified_indices_array, achieved_error]
        const targetIndexCount = targetTriCount * 3;
        const targetError = 0.01; // Allow 1% error for better quality
        
        console.log('Calling MeshoptSimplifier.simplify with:', {
          indicesLength: indices.length,
          verticesLength: vertices.length,
          vertexCount,
          targetIndexCount,
          targetError
        });
        
        const result = MeshoptSimplifier.simplify(
          indices,
          vertices,
          3, // stride (3 floats per vertex: x, y, z)
          targetIndexCount,
          targetError
        );
        
        console.log('Simplify result:', result);
        console.log('Result[0] type:', result[0]?.constructor?.name, 'length:', result[0]?.length);
        console.log('Result[1] (error):', result[1]);
        
        const newIndices = result[0]; // Simplified index array
        const newIndexCount = newIndices.length; // The array length IS the count
        
        if (newIndexCount === 0) {
          // Try with higher error tolerance
          console.log('Got 0 indices, trying with higher error tolerance...');
          const result2 = MeshoptSimplifier.simplify(
            indices,
            vertices,
            3,
            targetIndexCount,
            1.0 // Much higher error tolerance
          );
          console.log('Retry result:', result2[0]?.length, 'indices');
          
          if (result2[0]?.length === 0) {
            setStatus('Error: Simplification returned 0 triangles. Check console for details.');
            setProgress(0);
            return;
          }
        }
        
        setProgress(70);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        // Build new geometry from simplified indices
        // First, find which vertices are actually used
        const usedVertices = new Set();
        for (let i = 0; i < newIndexCount; i++) {
          usedVertices.add(newIndices[i]);
        }
        
        // Create compact vertex array and index remapping
        const vertexRemap = new Map();
        const newVertices = [];
        let newVertexIndex = 0;
        
        for (const oldIndex of usedVertices) {
          vertexRemap.set(oldIndex, newVertexIndex++);
          newVertices.push(
            vertices[oldIndex * 3],
            vertices[oldIndex * 3 + 1],
            vertices[oldIndex * 3 + 2]
          );
        }
        
        // Remap indices
        const remappedIndices = [];
        for (let i = 0; i < newIndexCount; i++) {
          remappedIndices.push(vertexRemap.get(newIndices[i]));
        }
        
        setProgress(85);
        
        // Create new geometry
        const simplifiedGeometry = new THREE.BufferGeometry();
        simplifiedGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newVertices, 3));
        simplifiedGeometry.setIndex(remappedIndices);
        simplifiedGeometry.computeVertexNormals();
        
        // Remove old simplified mesh
        if (simplifiedMesh) {
          scene.remove(simplifiedMesh);
          simplifiedMesh.geometry.dispose();
          simplifiedMesh.material.dispose();
        }
        
        // Create new simplified mesh (blue)
        const simplifiedMaterial = new THREE.MeshStandardMaterial({
          color: 0x4488ff,
          side: THREE.DoubleSide,
          wireframe: document.getElementById('show-wireframe').checked
        });
        
        simplifiedMesh = new THREE.Mesh(simplifiedGeometry, simplifiedMaterial);
        simplifiedMesh.visible = document.getElementById('show-simplified').checked;
        scene.add(simplifiedMesh);
        
        // Update stats
        const newTriCount = newIndexCount / 3;
        const newVertCount = newVertices.length / 3;
        const actualReduction = ((1 - newTriCount / originalTriCount) * 100).toFixed(1);
        const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
        
        document.getElementById('comparison-stats').style.display = 'grid';
        document.getElementById('compare-orig').textContent = Math.floor(originalTriCount).toLocaleString() + ' tris';
        document.getElementById('compare-simplified').textContent = Math.floor(newTriCount).toLocaleString() + ' tris';
        document.getElementById('stat-reduction').textContent = actualReduction + '% reduction';
        
        // Enable export
        document.getElementById('export-btn').disabled = false;
        
        setProgress(100);
        setStatus(`Simplified to ${Math.floor(newTriCount).toLocaleString()} triangles (${actualReduction}% reduction) in ${elapsed}s`);
        
        setTimeout(() => setProgress(0), 1000);
        
      } catch (err) {
        console.error('Error simplifying:', err);
        setStatus('Error: ' + err.message);
        setProgress(0);
      }
    };
    
    // ========== Toggle Functions ==========
    window.toggleOriginal = function() {
      if (originalMesh) {
        originalMesh.visible = document.getElementById('show-original').checked;
      }
    };
    
    window.toggleSimplified = function() {
      if (simplifiedMesh) {
        simplifiedMesh.visible = document.getElementById('show-simplified').checked;
      }
    };
    
    window.toggleWireframe = function() {
      const wireframe = document.getElementById('show-wireframe').checked;
      if (originalMesh) {
        originalMesh.material.wireframe = wireframe;
      }
      if (simplifiedMesh) {
        simplifiedMesh.material.wireframe = wireframe;
      }
    };
    
    // ========== Export ==========
    window.exportGLB = async function() {
      if (!simplifiedMesh) {
        setStatus('No simplified mesh to export.');
        return;
      }
      
      setStatus('Exporting GLB...');
      
      const exportScene = new THREE.Scene();
      const exportMesh = simplifiedMesh.clone();
      exportMesh.material = new THREE.MeshStandardMaterial({ color: 0xcccccc });
      exportScene.add(exportMesh);
      
      const exporter = new GLTFExporter();
      exporter.parse(
        exportScene,
        (gltf) => {
          const blob = new Blob([gltf], { type: 'model/gltf-binary' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'simplified-mesh.glb';
          a.click();
          URL.revokeObjectURL(url);
          setStatus('Exported simplified-mesh.glb');
        },
        (error) => {
          console.error('Export error:', error);
          setStatus('Export failed: ' + error.message);
        },
        { binary: true }
      );
    };
    
    // ========== Utilities ==========
    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }
    
    // ========== Resize ==========
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // ========== Animation Loop ==========
    function animate() {
      updateMovement();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>

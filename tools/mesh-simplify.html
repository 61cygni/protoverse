<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mesh Simplifier</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: #1a1a2e; 
      color: #eee;
      overflow: hidden;
    }
    #canvas-container {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 0;
    }
    canvas { 
      display: block; 
      touch-action: none;
    }
    
    /* Toolbar */
    #toolbar {
      position: fixed;
      top: 10px;
      left: 10px;
      bottom: 60px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 100;
      max-width: 300px;
      overflow-y: auto;
      padding-right: 5px;
    }
    #toolbar::-webkit-scrollbar { width: 6px; }
    #toolbar::-webkit-scrollbar-track { background: rgba(30, 30, 50, 0.5); border-radius: 3px; }
    #toolbar::-webkit-scrollbar-thumb { background: #4a4a6a; border-radius: 3px; }
    
    .toolbar-group {
      background: rgba(30, 30, 50, 0.95);
      border-radius: 8px;
      padding: 12px;
      border: 1px solid #3a3a5a;
      flex-shrink: 0;
    }
    .toolbar-group h3 {
      font-size: 11px;
      text-transform: uppercase;
      color: #888;
      margin-bottom: 8px;
      letter-spacing: 1px;
    }
    
    .btn {
      background: #2a2a4a;
      border: 1px solid #4a4a6a;
      color: #fff;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
      display: block;
      width: 100%;
      margin-bottom: 4px;
    }
    .btn:hover { background: #3a3a6a; border-color: #6a6a9a; }
    .btn:active { background: #4a4a7a; }
    .btn.primary { background: #4a6aaa; border-color: #6a8aca; }
    .btn.primary:hover { background: #5a7aba; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn.danger { background: #aa4a4a; border-color: #ca6a6a; }
    .btn.danger:hover { background: #ba5a5a; }
    .btn.small {
      font-size: 11px;
      padding: 4px 8px;
      margin-bottom: 0;
    }
    
    .prop-row {
      margin-bottom: 10px;
    }
    .prop-row label {
      display: block;
      font-size: 12px;
      color: #888;
      margin-bottom: 4px;
    }
    .prop-row input[type="range"] {
      width: 100%;
    }
    .prop-row .value {
      font-size: 11px;
      color: #6a8aca;
      float: right;
    }
    
    .stats-row {
      font-size: 11px;
      color: #888;
      margin-bottom: 4px;
    }
    .stats-row .label { color: #666; }
    .stats-row .value { color: #6a8aca; }
    .stats-row .value.good { color: #6aca6a; }
    .stats-row .value.warning { color: #caca6a; }
    
    /* Status bar */
    #status {
      position: fixed;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: rgba(30, 30, 50, 0.9);
      border-radius: 8px;
      padding: 10px 15px;
      font-size: 12px;
      color: #888;
      z-index: 100;
    }
    #status .hint { color: #6a8aca; }
    
    /* Progress */
    .progress-bar {
      height: 4px;
      background: #2a2a4a;
      border-radius: 2px;
      margin-top: 8px;
      overflow: hidden;
    }
    .progress-bar .fill {
      height: 100%;
      background: #4a9aff;
      width: 0%;
      transition: width 0.3s;
    }
    
    /* Toggle */
    .toggle-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .toggle-row label { font-size: 12px; color: #888; }
    input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }
    
    /* Comparison view */
    .comparison-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #3a3a5a;
    }
    .comparison-stats .col {
      text-align: center;
    }
    .comparison-stats .col-label {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    .comparison-stats .col-value {
      font-size: 14px;
      color: #6a8aca;
    }

  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <div id="toolbar">
    <div class="toolbar-group">
      <h3>1. Load Mesh</h3>
      <button class="btn" onclick="document.getElementById('file-input').click()">Load .glb / .gltf file</button>
      <input type="file" id="file-input" accept=".glb,.gltf" style="display:none">
      <div id="original-stats" style="margin-top: 8px;">
        <div class="stats-row"><span class="label">Original Vertices:</span> <span class="value" id="stat-orig-verts">-</span></div>
        <div class="stats-row"><span class="label">Original Triangles:</span> <span class="value" id="stat-orig-tris">-</span></div>
        <div class="stats-row"><span class="label">File Size:</span> <span class="value" id="stat-file-size">-</span></div>
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3>3. Patch Tool</h3>
      <div class="toggle-row">
        <input type="checkbox" id="patch-mode" onchange="togglePatchMode()">
        <label for="patch-mode">Enable Patch Mode</label>
      </div>
      <div class="toggle-row">
        <input type="checkbox" id="snap-to-surface" checked onchange="toggleSnapToSurface()">
        <label for="snap-to-surface">Snap to mesh surface</label>
      </div>
      <div class="toggle-row">
        <input type="checkbox" id="align-to-normal" onchange="toggleAlignToNormal()">
        <label for="align-to-normal">Align to surface normal</label>
      </div>
      <div class="prop-row">
        <label>Patch Size <span class="value" id="patch-size-value">0.50</span></label>
        <input type="range" id="patch-size" min="0.05" max="5" step="0.05" value="0.50" oninput="updatePatchSize()">
      </div>
      <div class="prop-row">
        <label>Patch Distance (fallback) <span class="value" id="patch-distance-value">1.00</span></label>
        <input type="range" id="patch-distance" min="0.1" max="10" step="0.1" value="1.00" oninput="updatePatchDistance()">
      </div>
      <div class="prop-row">
        <label>Brush Spacing <span class="value" id="patch-spacing-value">0.25</span></label>
        <input type="range" id="patch-spacing" min="0.05" max="2" step="0.05" value="0.25" oninput="updatePatchSpacing()">
      </div>
      <div class="stats-row">
        Click/drag to paint quads onto the mesh. Patches face the camera.
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3>4. Simplify</h3>
      <div class="prop-row">
        <label>Target Reduction <span class="value" id="reduction-value">50%</span></label>
        <input type="range" id="reduction-slider" min="10" max="95" value="50" oninput="updateReductionValue()">
      </div>
      <div class="prop-row">
        <label>Target Triangles <span class="value" id="target-tris-value">-</span></label>
      </div>
      <button class="btn primary" id="simplify-btn" onclick="simplifyMesh()" disabled>Simplify Mesh</button>
      <div class="progress-bar"><div class="fill" id="progress"></div></div>
      
      <div class="comparison-stats" id="comparison-stats" style="display: none;">
        <div class="col">
          <div class="col-label">Original</div>
          <div class="col-value" id="compare-orig">-</div>
        </div>
        <div class="col">
          <div class="col-label">Simplified</div>
          <div class="col-value" id="compare-simplified">-</div>
        </div>
      </div>
    </div>
    
    <div class="toolbar-group">
      <h3>5. Preview</h3>
      <div class="toggle-row">
        <input type="checkbox" id="show-original" checked onchange="toggleOriginal()">
        <label for="show-original">Show original (gray)</label>
      </div>
      <div class="toggle-row">
        <input type="checkbox" id="show-simplified" checked onchange="toggleSimplified()">
        <label for="show-simplified">Show simplified (blue)</label>
      </div>
      <div class="toggle-row">
        <input type="checkbox" id="show-wireframe" onchange="toggleWireframe()">
        <label for="show-wireframe">Wireframe mode</label>
      </div>
      <div class="prop-row">
        <label>Move Speed <span class="value" id="speed-value">0.15</span></label>
        <input type="range" id="speed-slider" min="0.01" max="1" step="0.01" value="0.15" oninput="updateSpeed()">
      </div>
      <button class="btn" onclick="resetCamera()">Reset Camera</button>
    </div>
    
    <div class="toolbar-group">
      <h3>6. Export</h3>
      <button class="btn primary" id="export-btn" onclick="exportGLB()" disabled>Export Simplified .glb</button>
      <div class="stats-row" style="margin-top: 8px;">
        <span class="label">Reduction:</span> <span class="value" id="stat-reduction">-</span>
      </div>
    </div>
  </div>
  
  <div id="status">
    Loading meshoptimizer...
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
  }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    
    // Load three-mesh-bvh for fast raycasting
    let bvhReady = false;
    let computeBoundsTree, disposeBoundsTree, acceleratedRaycast;
    
    async function initBVH() {
      try {
        const bvhModule = await import('https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.7.8/+esm');
        computeBoundsTree = bvhModule.computeBoundsTree;
        disposeBoundsTree = bvhModule.disposeBoundsTree;
        acceleratedRaycast = bvhModule.acceleratedRaycast;
        
        // Extend Three.js with BVH acceleration
        THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
        THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
        THREE.Mesh.prototype.raycast = acceleratedRaycast;
        
        bvhReady = true;
        console.log('three-mesh-bvh loaded and ready');
      } catch (err) {
        console.warn('Failed to load three-mesh-bvh, raycasting will be slow:', err);
      }
    }
    initBVH();
    // No orbit/pointer lock controls; we use drag-to-look + WASD.
    
    // ========== Utilities (defined early for initMeshopt) ==========
    function setStatus(msg) {
      document.getElementById('status').innerHTML = msg;
    }
    
    function setProgress(percent) {
      document.getElementById('progress').style.width = percent + '%';
    }
    
    // ========== Meshoptimizer WASM (fast O(n log n) simplification) ==========
    // meshoptimizer by Arseny Kapoulkine - used by Unity, Unreal, etc.
    // Much faster than Three.js SimplifyModifier for large meshes
    let meshoptReady = false;
    let MeshoptSimplifier = null;
    
    // Load meshoptimizer WASM
    async function initMeshopt() {
      try {
        setStatus('Loading meshoptimizer WASM...');
        const module = await import('https://cdn.jsdelivr.net/npm/meshoptimizer@0.21.0/meshopt_simplifier.module.js');
        console.log('Meshopt module:', module);
        console.log('Module keys:', Object.keys(module));
        
        MeshoptSimplifier = module.MeshoptSimplifier;
        console.log('MeshoptSimplifier:', MeshoptSimplifier);
        console.log('MeshoptSimplifier methods:', Object.keys(MeshoptSimplifier));
        
        await MeshoptSimplifier.ready;
        meshoptReady = true;
        
        // Quick test with tiny mesh
        const testIndices = new Uint32Array([0, 1, 2]);
        const testVerts = new Float32Array([0,0,0, 1,0,0, 0,1,0]);
        const testResult = MeshoptSimplifier.simplify(testIndices, testVerts, 3, 3, 0.01);
        console.log('Test simplify result:', testResult, 'length:', testResult[0]?.length);
        
        setStatus('<span class="hint">Drag</span> to look. WASD to move, mouse drag to look, R/F (or Q/E) up/down, Shift = fast.');
        console.log('Meshoptimizer ready');
      } catch (err) {
        console.error('Failed to load meshoptimizer:', err);
        setStatus('Error: Failed to load meshoptimizer. Check console.');
      }
    }
    initMeshopt();
    
    // ========== Scene Setup ==========
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 10000);
    camera.position.set(5, 5, 5);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);
    
    camera.rotation.order = 'YXZ';
    
    // ========== State ==========
    let originalMesh = null;
    let simplifiedMesh = null;
    let originalTriCount = 0;
    let originalVertCount = 0;
    let fileSize = 0;
    let patchMode = false;
    let patchSize = 0.5;
    let patchDistance = 1.0;
    let patchSpacing = 0.25;
    let patchPlane = null;
    let isPainting = false;
    let lastPaintPosition = null;
    let snapToSurface = true;  // Snap patches to mesh surface
    let alignToNormal = false; // Align patch to surface normal (vs face camera)
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    // ========== WASD + Drag-Look Controls ==========
    const keyState = {};
    let moveSpeed = 0.15;
    let isMouseDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let yaw = 0;
    let pitch = 0;
    const lookSensitivity = 0.0025;
    
    document.addEventListener('keydown', (e) => {
      keyState[e.code] = true;
      // Prevent default for movement keys
      if (['KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyQ', 'KeyE', 'KeyR', 'KeyF', 'Space', 'ShiftLeft', 'ShiftRight'].includes(e.code)) {
        e.preventDefault();
      }
    });
    
    document.addEventListener('keyup', (e) => {
      keyState[e.code] = false;
    });

    renderer.domElement.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      isMouseDragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });

    renderer.domElement.addEventListener('mouseup', () => {
      isMouseDragging = false;
    });

    renderer.domElement.addEventListener('mouseleave', () => {
      isMouseDragging = false;
    });

    renderer.domElement.addEventListener('mousemove', (e) => {
      if (!isMouseDragging) return;
      const dx = e.clientX - lastMouseX;
      const dy = e.clientY - lastMouseY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;

      yaw -= dx * lookSensitivity;
      pitch -= dy * lookSensitivity;
      const maxPitch = Math.PI / 2 - 0.01;
      pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));

      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
    });
    
    function updateMovement() {
      // Speed modifier
      const speed = keyState['ShiftLeft'] || keyState['ShiftRight'] ? moveSpeed * 3 : moveSpeed;
      
      // Get camera direction vectors
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();

      const right = new THREE.Vector3();
      right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

      const movement = new THREE.Vector3();

      // WASD movement
      if (keyState['KeyW'] || keyState['ArrowUp']) movement.add(forward.clone().multiplyScalar(speed));
      if (keyState['KeyS'] || keyState['ArrowDown']) movement.add(forward.clone().multiplyScalar(-speed));
      if (keyState['KeyA'] || keyState['ArrowLeft']) movement.add(right.clone().multiplyScalar(-speed));
      if (keyState['KeyD'] || keyState['ArrowRight']) movement.add(right.clone().multiplyScalar(speed));

      // Q/E/R/F or Space for up/down
      if (keyState['KeyE'] || keyState['KeyR'] || keyState['Space']) movement.y += speed;
      if (keyState['KeyQ'] || keyState['KeyF']) movement.y -= speed;

      if (movement.lengthSq() > 0) {
        camera.position.add(movement);
      }
    }

    // Patch mode mouse handling (throttled to avoid constant raycasting)
    let patchUpdatePending = false;
    renderer.domElement.addEventListener('mousemove', (e) => {
      if (!patchMode) return;
      updateMouse(e);
      
      // Throttle raycast updates
      if (!patchUpdatePending) {
        patchUpdatePending = true;
        requestAnimationFrame(() => {
          updatePatchPlane();
          if (isPainting) {
            maybePaintPatch();
          }
          patchUpdatePending = false;
        });
      }
    });

    renderer.domElement.addEventListener('mousedown', (e) => {
      if (!patchMode || e.button !== 0) return;
      updateMouse(e);
      updatePatchPlane();
      isPainting = true;
      lastPaintPosition = null;
      placePatch();
    });

    renderer.domElement.addEventListener('mouseup', () => {
      isPainting = false;
      lastPaintPosition = null;
    });

    function updateMouse(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function getPatchTargetMesh() {
      return simplifiedMesh || null;
    }

    function updatePatchPlane() {
      raycaster.setFromCamera(mouse, camera);
      
      // If snap-to-surface is enabled, try to hit the mesh
      const targetMesh = getPatchTargetMesh();
      if (snapToSurface && targetMesh) {
        // Temporarily make mesh visible for raycasting (raycast ignores invisible objects)
        const wasVisible = targetMesh.visible;
        targetMesh.visible = true;
        
        const intersects = raycaster.intersectObject(targetMesh, false);
        
        // Restore visibility
        targetMesh.visible = wasVisible || document.getElementById('show-simplified').checked;
        
        if (intersects.length > 0) {
          const hit = intersects[0];
          patchPlane.position.copy(hit.point);
          
          // Offset slightly towards camera so patch sits ON surface, not inside
          const toCamera = camera.position.clone().sub(hit.point).normalize();
          patchPlane.position.addScaledVector(toCamera, 0.01);
          
          // Optionally align to surface normal or face camera
          if (alignToNormal && hit.face) {
            // Align patch to surface normal
            const normal = hit.face.normal.clone().transformDirection(targetMesh.matrixWorld);
            patchPlane.lookAt(patchPlane.position.clone().add(normal));
          } else {
            patchPlane.lookAt(camera.position);
          }
          patchPlane.scale.setScalar(patchSize);
          patchPlane.material.color.setHex(0x44ff44); // Green = on surface
          return;
        }
      }
      
      // Fallback: place at fixed distance (red = not on surface)
      const point = raycaster.ray.at(patchDistance, new THREE.Vector3());
      patchPlane.position.copy(point);
      patchPlane.scale.setScalar(patchSize);
      patchPlane.lookAt(camera.position);
      patchPlane.material.color.setHex(0xff4444); // Red = floating
    }

    function maybePaintPatch() {
      if (!patchPlane.visible) return;
      const current = patchPlane.position.clone();
      if (!lastPaintPosition || current.distanceTo(lastPaintPosition) >= patchSpacing) {
        placePatch();
        lastPaintPosition = current.clone();
      }
    }
    
    // Grid helper
    const grid = new THREE.GridHelper(20, 20, 0x444444, 0x333333);
    scene.add(grid);
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);

    // Patch preview plane (hidden until patch mode)
    const patchGeometry = new THREE.PlaneGeometry(1, 1);
    const patchMaterial = new THREE.MeshBasicMaterial({
      color: 0x44ff44,
      transparent: true,
      opacity: 0.35,
      side: THREE.DoubleSide,
      depthTest: false,
      depthWrite: false
    });
    patchPlane = new THREE.Mesh(patchGeometry, patchMaterial);
    patchPlane.visible = false;
    scene.add(patchPlane);
    
    // ========== File Loading ==========
    const fileInput = document.getElementById('file-input');
    
    document.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
    
    document.addEventListener('drop', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      const file = e.dataTransfer.files[0];
      if (file && (file.name.endsWith('.glb') || file.name.endsWith('.gltf'))) {
        await loadGLBFile(file);
      }
    });
    
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) {
        await loadGLBFile(file);
      }
    });
    
    async function loadGLBFile(file) {
      try {
        setStatus('Loading mesh...');
        fileSize = file.size;
        
        const arrayBuffer = await file.arrayBuffer();
        const loader = new GLTFLoader();
        
        const gltf = await new Promise((resolve, reject) => {
          loader.parse(arrayBuffer, '', resolve, reject);
        });
        
        // Remove existing meshes
        if (originalMesh) {
          scene.remove(originalMesh);
          originalMesh.geometry.dispose();
          originalMesh.material.dispose();
        }
        if (simplifiedMesh) {
          scene.remove(simplifiedMesh);
          simplifiedMesh.geometry.dispose();
          simplifiedMesh.material.dispose();
          simplifiedMesh = null;
        }
        
        // Find all meshes and merge them
        const geometries = [];
        gltf.scene.traverse((child) => {
          if (child.isMesh) {
            const geo = child.geometry.clone();
            child.updateWorldMatrix(true, false);
            geo.applyMatrix4(child.matrixWorld);
            geometries.push(geo);
          }
        });
        
        if (geometries.length === 0) {
          setStatus('Error: No mesh found in file');
          return;
        }
        
        // Merge geometries if multiple
        let mergedGeometry;
        if (geometries.length === 1) {
          mergedGeometry = geometries[0];
        } else {
          mergedGeometry = mergeBufferGeometries(geometries);
        }
        
        // Make sure it's indexed (required for SimplifyModifier)
        if (!mergedGeometry.index) {
          mergedGeometry = toIndexedGeometry(mergedGeometry);
        }
        
        // Create original mesh (gray, slightly transparent)
        const originalMaterial = new THREE.MeshStandardMaterial({
          color: 0x888888,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.5
        });
        
        originalMesh = new THREE.Mesh(mergedGeometry, originalMaterial);
        originalMesh.visible = document.getElementById('show-original').checked;
        scene.add(originalMesh);
        
        // Build BVH for fast raycasting (critical for large meshes)
        if (bvhReady && mergedGeometry.computeBoundsTree) {
          setStatus('Building BVH for fast raycasting...');
          await new Promise(resolve => setTimeout(resolve, 10));
          mergedGeometry.computeBoundsTree();
          console.log('BVH built for', originalTriCount, 'triangles');
        } else {
          console.warn('BVH not available, raycasting may be slow');
        }

        // Update stats
        originalVertCount = mergedGeometry.getAttribute('position').count;
        originalTriCount = mergedGeometry.index ? mergedGeometry.index.count / 3 : originalVertCount / 3;
        
        document.getElementById('stat-orig-verts').textContent = originalVertCount.toLocaleString();
        document.getElementById('stat-orig-tris').textContent = Math.floor(originalTriCount).toLocaleString();
        document.getElementById('stat-file-size').textContent = formatFileSize(fileSize);
        
        // Enable simplify button
        document.getElementById('simplify-btn').disabled = false;
        updateReductionValue();
        
        // Center camera
        centerCamera();
        
        // Hide comparison stats
        document.getElementById('comparison-stats').style.display = 'none';
        document.getElementById('export-btn').disabled = true;
        document.getElementById('stat-reduction').textContent = '-';
        
        setStatus(`Loaded mesh with ${originalTriCount.toLocaleString()} triangles. Adjust reduction and click Simplify.`);
        
      } catch (err) {
        console.error('Error loading GLB:', err);
        setStatus('Error: ' + err.message);
      }
    }
    
    // Simple geometry merge (since BufferGeometryUtils may not be in all Three.js versions)
    function mergeBufferGeometries(geometries) {
      const positions = [];
      const indices = [];
      let indexOffset = 0;
      
      for (const geo of geometries) {
        const pos = geo.getAttribute('position');
        for (let i = 0; i < pos.count; i++) {
          positions.push(pos.getX(i), pos.getY(i), pos.getZ(i));
        }
        
        if (geo.index) {
          const idx = geo.index;
          for (let i = 0; i < idx.count; i++) {
            indices.push(idx.getX(i) + indexOffset);
          }
        } else {
          for (let i = 0; i < pos.count; i++) {
            indices.push(i + indexOffset);
          }
        }
        
        indexOffset += pos.count;
      }
      
      const merged = new THREE.BufferGeometry();
      merged.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      merged.setIndex(indices);
      merged.computeVertexNormals();
      
      return merged;
    }
    
    // Convert non-indexed geometry to indexed
    function toIndexedGeometry(geometry) {
      const positions = geometry.getAttribute('position');
      const vertexMap = new Map();
      const newPositions = [];
      const indices = [];
      
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);
        const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;
        
        if (vertexMap.has(key)) {
          indices.push(vertexMap.get(key));
        } else {
          const idx = newPositions.length / 3;
          vertexMap.set(key, idx);
          newPositions.push(x, y, z);
          indices.push(idx);
        }
      }
      
      const indexed = new THREE.BufferGeometry();
      indexed.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
      indexed.setIndex(indices);
      indexed.computeVertexNormals();
      
      return indexed;
    }
    
    function centerCamera() {
      if (!originalMesh) return;
      
      const bounds = new THREE.Box3().setFromObject(originalMesh);
      const center = bounds.getCenter(new THREE.Vector3());
      const size = bounds.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z) || 10;
      
      camera.position.set(
        center.x + maxDim * 1.2,
        center.y + maxDim * 0.8,
        center.z + maxDim * 1.2
      );
      camera.lookAt(center);
      yaw = camera.rotation.y;
      pitch = camera.rotation.x;
    }
    
    window.resetCamera = centerCamera;
    
    window.updateSpeed = function() {
      moveSpeed = parseFloat(document.getElementById('speed-slider').value);
      document.getElementById('speed-value').textContent = moveSpeed.toFixed(2);
    };

    // Initialize patch UI values (after functions are defined)
    setTimeout(() => {
      window.updatePatchSize();
      window.updatePatchDistance();
      window.updatePatchSpacing();
    }, 0);

    function updatePatchVisibility() {
      const showSimplified = document.getElementById('show-simplified').checked;
      patchPlane.visible = patchMode && showSimplified && !!simplifiedMesh;
    }

    window.togglePatchMode = function() {
      patchMode = document.getElementById('patch-mode').checked;
      updatePatchVisibility();
      isPainting = false;
      lastPaintPosition = null;
      if (patchMode) {
        if (!simplifiedMesh) {
          setStatus('Patch mode enabled, but requires a simplified mesh. Run Simplify first.');
        } else {
          setStatus('Patch mode enabled. Click/drag to paint quads (faces camera).');
        }
      } else {
        setStatus('Patch mode disabled.');
      }
    };

    window.updatePatchSize = function() {
      patchSize = parseFloat(document.getElementById('patch-size').value);
      document.getElementById('patch-size-value').textContent = patchSize.toFixed(2);
      if (patchPlane) patchPlane.scale.setScalar(patchSize);
    };

    window.updatePatchDistance = function() {
      patchDistance = parseFloat(document.getElementById('patch-distance').value);
      document.getElementById('patch-distance-value').textContent = patchDistance.toFixed(2);
    };

    window.toggleSnapToSurface = function() {
      snapToSurface = document.getElementById('snap-to-surface').checked;
    };

    window.toggleAlignToNormal = function() {
      alignToNormal = document.getElementById('align-to-normal').checked;
    };

    window.updatePatchSpacing = function() {
      patchSpacing = parseFloat(document.getElementById('patch-spacing').value);
      document.getElementById('patch-spacing-value').textContent = patchSpacing.toFixed(2);
    };

    function updateOriginalStats() {
      if (!originalMesh) return;
      const geometry = originalMesh.geometry;
      originalVertCount = geometry.getAttribute('position').count;
      originalTriCount = geometry.getIndex() ? geometry.getIndex().count / 3 : originalVertCount / 3;
      document.getElementById('stat-orig-verts').textContent = originalVertCount.toLocaleString();
      document.getElementById('stat-orig-tris').textContent = Math.floor(originalTriCount).toLocaleString();
      window.updateReductionValue();
    }

    function placePatch() {
      const targetMesh = getPatchTargetMesh();
      if (!targetMesh || !patchPlane.visible) {
        if (!targetMesh) {
          setStatus('Patch tool requires a simplified mesh. Run Simplify first.');
        }
        return;
      }

      try {
        const oldGeometry = targetMesh.geometry;
        const posAttr = oldGeometry.getAttribute('position');
        if (!posAttr) return;

        // Compute quad corners in world space
        const half = patchSize * 0.5;
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(patchPlane.quaternion);
        const up = new THREE.Vector3(0, 1, 0).applyQuaternion(patchPlane.quaternion);
        const center = patchPlane.position.clone();

        const p0 = center.clone().addScaledVector(right, -half).addScaledVector(up, -half);
        const p1 = center.clone().addScaledVector(right, half).addScaledVector(up, -half);
        const p2 = center.clone().addScaledVector(right, -half).addScaledVector(up, half);
        const p3 = center.clone().addScaledVector(right, half).addScaledVector(up, half);

        const oldVertexCount = posAttr.count;
        const baseIndex = oldVertexCount;
        const newVertexCount = oldVertexCount + 4;

        // Copy positions safely (handles interleaved attributes)
        const newPositions = new Float32Array(newVertexCount * 3);
        for (let i = 0; i < oldVertexCount; i++) {
          newPositions[i * 3] = posAttr.getX(i);
          newPositions[i * 3 + 1] = posAttr.getY(i);
          newPositions[i * 3 + 2] = posAttr.getZ(i);
        }
        newPositions.set(
          [p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p2.x, p2.y, p2.z, p3.x, p3.y, p3.z],
          oldVertexCount * 3
        );

        // Build index buffer
        const oldIndexAttr = oldGeometry.getIndex();
        const oldIndexCount = oldIndexAttr ? oldIndexAttr.count : oldVertexCount;
        const newIndices = new Uint32Array(oldIndexCount + 6);

        if (oldIndexAttr) {
          for (let i = 0; i < oldIndexCount; i++) {
            newIndices[i] = oldIndexAttr.getX(i);
          }
        } else {
          for (let i = 0; i < oldVertexCount; i++) {
            newIndices[i] = i;
          }
        }

        // Two triangles: (p0, p1, p2) and (p2, p1, p3)
        newIndices[oldIndexCount] = baseIndex;
        newIndices[oldIndexCount + 1] = baseIndex + 1;
        newIndices[oldIndexCount + 2] = baseIndex + 2;
        newIndices[oldIndexCount + 3] = baseIndex + 2;
        newIndices[oldIndexCount + 4] = baseIndex + 1;
        newIndices[oldIndexCount + 5] = baseIndex + 3;

        // Create entirely new geometry to avoid WebGL buffer issues
        const newGeometry = new THREE.BufferGeometry();
        newGeometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
        newGeometry.setIndex(new THREE.BufferAttribute(newIndices, 1));
        newGeometry.computeVertexNormals();
        newGeometry.computeBoundingSphere();

        // Swap geometry
        targetMesh.geometry = newGeometry;
        if (oldGeometry.disposeBoundsTree) oldGeometry.disposeBoundsTree();
        oldGeometry.dispose();
        
        // Rebuild BVH for continued raycasting
        if (bvhReady && newGeometry.computeBoundsTree) {
          newGeometry.computeBoundsTree();
        }

        updateOriginalStats();
      } catch (err) {
        console.error('placePatch error:', err);
        setStatus('Error placing patch: ' + err.message);
      }
    }
    
    // ========== Simplification ==========
    window.updateReductionValue = function() {
      const val = document.getElementById('reduction-slider').value;
      document.getElementById('reduction-value').textContent = val + '%';
      
      if (originalTriCount > 0) {
        const targetTris = Math.floor(originalTriCount * (1 - val / 100));
        document.getElementById('target-tris-value').textContent = targetTris.toLocaleString();
      }
    };
    
    window.simplifyMesh = async function() {
      if (!originalMesh) return;
      
      if (!meshoptReady) {
        setStatus('Error: meshoptimizer not loaded yet. Please wait...');
        return;
      }
      
      setStatus('Simplifying mesh (meshoptimizer)...');
      setProgress(10);
      
      // Allow UI to update
      await new Promise(resolve => setTimeout(resolve, 50));
      
      const startTime = performance.now();
      
      try {
        const reduction = document.getElementById('reduction-slider').value / 100;
        const targetTriCount = Math.max(4, Math.floor(originalTriCount * (1 - reduction)));
        
        // Get geometry data
        const geometry = originalMesh.geometry;
        const positions = geometry.getAttribute('position');
        const index = geometry.getIndex();
        
        if (!index) {
          setStatus('Error: Mesh must be indexed');
          return;
        }
        
        // Convert to flat arrays for meshoptimizer
        const vertexCount = positions.count;
        const indexCount = index.count;
        
        // Create vertex array (positions only, 3 floats per vertex)
        const vertices = new Float32Array(vertexCount * 3);
        for (let i = 0; i < vertexCount; i++) {
          vertices[i * 3] = positions.getX(i);
          vertices[i * 3 + 1] = positions.getY(i);
          vertices[i * 3 + 2] = positions.getZ(i);
        }
        
        // Create index array
        const indices = new Uint32Array(indexCount);
        for (let i = 0; i < indexCount; i++) {
          indices[i] = index.getX(i);
        }
        
        // Debug: Check data validity (sample only to avoid perf issues)
        let maxIdx = 0;
        for (let i = 0; i < indices.length; i++) {
          if (indices[i] > maxIdx) maxIdx = indices[i];
        }
        
        console.log('Input validation:', {
          vertexCount,
          indexCount,
          triangleCount: indexCount / 3,
          verticesArrayLength: vertices.length,
          indicesArrayLength: indices.length,
          maxIndex: maxIdx,
          sampleVertices: [vertices[0], vertices[1], vertices[2]],
          sampleIndices: [indices[0], indices[1], indices[2]]
        });
        
        // Validate indices are within bounds
        if (maxIdx >= vertexCount) {
          console.error('Invalid mesh: index', maxIdx, 'exceeds vertex count', vertexCount);
          setStatus('Error: Invalid mesh - indices out of bounds');
          return;
        }
        
        setProgress(30);
        setStatus(`Simplifying ${originalTriCount.toLocaleString()} â†’ ${targetTriCount.toLocaleString()} triangles...`);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        console.log(`Simplifying: ${indexCount / 3} -> ${targetTriCount} triangles`);
        
        // Run meshoptimizer simplification
        // simplify(indices, vertices, vertex_stride, target_index_count, target_error)
        // Returns [simplified_indices_array, achieved_error]
        const targetIndexCount = targetTriCount * 3;
        const targetError = 0.01; // Allow 1% error for better quality
        
        console.log('Calling MeshoptSimplifier.simplify with:', {
          indicesLength: indices.length,
          verticesLength: vertices.length,
          vertexCount,
          targetIndexCount,
          targetError
        });
        
        const result = MeshoptSimplifier.simplify(
          indices,
          vertices,
          3, // stride (3 floats per vertex: x, y, z)
          targetIndexCount,
          targetError
        );
        
        console.log('Simplify result:', result);
        console.log('Result[0] type:', result[0]?.constructor?.name, 'length:', result[0]?.length);
        console.log('Result[1] (error):', result[1]);
        
        const newIndices = result[0]; // Simplified index array
        const newIndexCount = newIndices.length; // The array length IS the count
        
        if (newIndexCount === 0) {
          // Try with higher error tolerance
          console.log('Got 0 indices, trying with higher error tolerance...');
          const result2 = MeshoptSimplifier.simplify(
            indices,
            vertices,
            3,
            targetIndexCount,
            1.0 // Much higher error tolerance
          );
          console.log('Retry result:', result2[0]?.length, 'indices');
          
          if (result2[0]?.length === 0) {
            setStatus('Error: Simplification returned 0 triangles. Check console for details.');
            setProgress(0);
            return;
          }
        }
        
        setProgress(70);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        // Build new geometry from simplified indices
        // First, find which vertices are actually used
        const usedVertices = new Set();
        for (let i = 0; i < newIndexCount; i++) {
          usedVertices.add(newIndices[i]);
        }
        
        // Create compact vertex array and index remapping
        const vertexRemap = new Map();
        const newVertices = [];
        let newVertexIndex = 0;
        
        for (const oldIndex of usedVertices) {
          vertexRemap.set(oldIndex, newVertexIndex++);
          newVertices.push(
            vertices[oldIndex * 3],
            vertices[oldIndex * 3 + 1],
            vertices[oldIndex * 3 + 2]
          );
        }
        
        // Remap indices
        const remappedIndices = [];
        for (let i = 0; i < newIndexCount; i++) {
          remappedIndices.push(vertexRemap.get(newIndices[i]));
        }
        
        setProgress(85);
        
        // Create new geometry
        const simplifiedGeometry = new THREE.BufferGeometry();
        simplifiedGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newVertices, 3));
        simplifiedGeometry.setIndex(remappedIndices);
        simplifiedGeometry.computeVertexNormals();
        
        // Remove old simplified mesh
        if (simplifiedMesh) {
          scene.remove(simplifiedMesh);
          simplifiedMesh.geometry.dispose();
          simplifiedMesh.material.dispose();
        }
        
        // Create new simplified mesh (blue)
        const simplifiedMaterial = new THREE.MeshStandardMaterial({
          color: 0x4488ff,
          side: THREE.DoubleSide,
          wireframe: document.getElementById('show-wireframe').checked
        });
        
        simplifiedMesh = new THREE.Mesh(simplifiedGeometry, simplifiedMaterial);
        simplifiedMesh.visible = document.getElementById('show-simplified').checked;
        scene.add(simplifiedMesh);
        updatePatchVisibility();
        
        // Update stats
        const newTriCount = newIndexCount / 3;
        const newVertCount = newVertices.length / 3;
        const actualReduction = ((1 - newTriCount / originalTriCount) * 100).toFixed(1);
        const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
        
        document.getElementById('comparison-stats').style.display = 'grid';
        document.getElementById('compare-orig').textContent = Math.floor(originalTriCount).toLocaleString() + ' tris';
        document.getElementById('compare-simplified').textContent = Math.floor(newTriCount).toLocaleString() + ' tris';
        document.getElementById('stat-reduction').textContent = actualReduction + '% reduction';
        
        // Enable export
        document.getElementById('export-btn').disabled = false;
        
        setProgress(100);
        setStatus(`Simplified to ${Math.floor(newTriCount).toLocaleString()} triangles (${actualReduction}% reduction) in ${elapsed}s`);
        
        setTimeout(() => setProgress(0), 1000);
        
      } catch (err) {
        console.error('Error simplifying:', err);
        setStatus('Error: ' + err.message);
        setProgress(0);
      }
    };
    
    // ========== Toggle Functions ==========
    window.toggleOriginal = function() {
      if (originalMesh) {
        originalMesh.visible = document.getElementById('show-original').checked;
      }
    };
    
    window.toggleSimplified = function() {
      if (simplifiedMesh) {
        simplifiedMesh.visible = document.getElementById('show-simplified').checked;
      }
      if (patchPlane) {
        updatePatchVisibility();
      }
    };
    
    window.toggleWireframe = function() {
      const wireframe = document.getElementById('show-wireframe').checked;
      if (originalMesh) {
        originalMesh.material.wireframe = wireframe;
      }
      if (simplifiedMesh) {
        simplifiedMesh.material.wireframe = wireframe;
      }
    };
    
    // ========== Export ==========
    window.exportGLB = async function() {
      if (!simplifiedMesh) {
        setStatus('No simplified mesh to export.');
        return;
      }
      
      setStatus('Exporting GLB...');
      
      const exportScene = new THREE.Scene();
      const exportMesh = simplifiedMesh.clone();
      exportMesh.material = new THREE.MeshStandardMaterial({ color: 0xcccccc });
      exportScene.add(exportMesh);
      
      const exporter = new GLTFExporter();
      exporter.parse(
        exportScene,
        (gltf) => {
          const blob = new Blob([gltf], { type: 'model/gltf-binary' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'simplified-mesh.glb';
          a.click();
          URL.revokeObjectURL(url);
          setStatus('Exported simplified-mesh.glb');
        },
        (error) => {
          console.error('Export error:', error);
          setStatus('Export failed: ' + error.message);
        },
        { binary: true }
      );
    };
    
    // ========== Utilities ==========
    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
    }
    
    // ========== Resize ==========
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // ========== Animation Loop ==========
    function animate() {
      updateMovement();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>
